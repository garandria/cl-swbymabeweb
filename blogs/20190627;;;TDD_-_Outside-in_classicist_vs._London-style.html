<p>OK, I don't want/need to explain TDD.</p>
<p>As for 'Outside-in', it is a development approach where you start developing at the boundary of a system on a use-case basis.<br />This can be a web service, a web page, a CLI interface or something else.<br />You could say that it's a vertical slice through the system where you add the behavior for the use-case.</p>
<p>But you start your coding with an integration test which expects the right outcome, but since nothing is coded yet it will fail until the very end.<br />The integration tests makes sure that all components are eventually properly wired together, and can produce the side-effect or direct outcome that is expected.</p>
<h4>So what is 'classicist'?</h4>
<p>With 'classicist' we mean the original TDD approach or red-green-refactor cycle and triangulation where the production code is developed in small steps.<br />In between (in the refactor step) you want to do refactorings and carve out collaborators, find abstractions, etc., <br />but your tests should not be changed once they were green. The refactorings you do are internal, not externally visible.<br />Your tests implicitly test the behavior of helper classes like collaborators.<br />You don't usually do a lot of mocking, in particular not of the collaborators.</p>
<h4>'London style'&nbsp;</h4>
<p>'London style' is different in that you explicitly think about any collaborations and helper classes while you write the test.<br />So you do more during the 'red' step and therefore the yellow (refactor) step is shorter than in classicist.<br />As a consequence you have to mock out those collaborators, because you know about them and want to control them.<br />On a new system you can carve out a lot of the architecture and design this way.</p>
<p>So basically, while 'classicist' drives design passively and as a refactoring, 'London style' drives it actively through mocking.</p>
<p>Some say that this ('London style') actually tests internals, which you should avoid.<br />But I think we have to look at this from a different perspective.<br />As a tester and designer I would want to know which classes collaborate and use other classes. And this is satisfied by the mocking.</p>
